#! /usr/bin/pwsh
# This script handles managing an Erlang node as a Windows service.
#
# Commands provided:
#
# * install - install the release as a Windows service
# * start - start the service and Erlang node
# * stop - stop the service and Erlang node
# * restart - run the stop command and start command
# * uninstall - uninstall the service and kill a running node
# * ping - check if the node is running
# * console - start the Erlang release in a `werl` Windows shell
# * attach - connect to a running node and open an interactive console
# * remote_console - alias for attach
# * list - display a listing of installed Erlang services
# * usage - display available commands
param (
    [string] $Command
)

# Terminate on error
$ErrorActionPreference = "Stop"

# Set variables that describe the release
$rel_name = '{{ rel_name }}'
$rel_vsn = '{{ rel_vsn }}'
$erts_vsn = '{{ erts_vsn }}'
$erl_opts = '{{ erl_opts }}'

# Ensure we have PSScriptRoot
if (!(Test-Path variable:global:PSScriptRoot)) {
    # Support powershell 2.0
    $PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition
}

# Import psutil helper functions
. $PSScriptRoot\psutil.ps1

# Set the root release directory based on the location of this batch file
$rootdir = Split-Path -Parent -Path $PSScriptRoot
$rel_dir = "$rootdir\releases\$rel_vsn"

$erts_root, $erts_dir = Find-ERTS -RelRoot $rootdir -Vsn $erts_vsn
$sys_config = Find-FormatConfig -RelDir $rel_dir -File 'sys.config'
$vm_args = Find-FormatConfig -RelDir $rel_dir -File 'vm.args'
$boot_script = Find-BootScript -RelDir $rel_dir -RelName $rel_name

$service_name = "${rel_name}_${rel_vsn}"
$nodetool = "$rootdir\bin\nodetool"

$bindir = "$erts_dir\bin"
$werl = "$bindir\werl.exe"
$erlsrv = "$bindir\erlsrv.exe"
$epmd = "$bindir\epmd.exe"
$escript = "$bindir\escript.exe"

$extensions = @("{{ extensions }}" -split '[|]' | Where-Object { $_ -ne 'undefined' })

# Run extension script
function RunExtension() {
    param(
        [string]$Name
    )
    # Manifest xxx_extension as local variable
    "{{ extension_declarations }}" -split ";" | ForEach-Object { Invoke-Expression "`$$_" }
    # Manifest value of xxx_extension as $script
    $script = Invoke-Expression "`$${Name}_extension"
    # Execute
    & "$PSScriptRoot\$script" @args
}

# Extract node type and name from vm.args
$node_type, $node_name, $hostname = Get-NodeAndHost $vm_args

# Extract the target cookie
# Do this before relx_get_nodename so we can use it and not create a ~/.erlang.cookie
$cookie = Get-Cookie $vm_args

# Collect additional (allowed) VM args into erl_opts for erlsrv/start_erl
$opts = Get-Content $vm_args `
    | Select-String '^(#|-name|-sname|-setcookie|-noinput|-noshell)' -NotMatch `
    | ForEach-Object { $_.line } `
    | Where-Object { $_.length -gt 0 }
$erl_opts += "$opts"

# If a start.boot file is not present, copy one from the named .boot file
if (!(Test-Path "$rel_dir\start.boot")) {
    Copy-Item "$rel_dir\$rel_name.boot" "$rel_dir\start.boot" | Out-Null
}

# List of supported commands, help, etc
$commands = @{
    'install' = @{
        'ShortHelp' = 'Install the service';
        'LongHelp' = 'Installs release <version> as a windows service';
        'Usage' = '<version>';
        'Invoke' = 'Install';
        'PassArgs' = $true
`    };
    'uninstall' = @{
        'ShortHelp' = 'Uninstall the service';
        'LongHelp' = 'Uninstalls release <version> as a windows service';
        'Usage' = '<version>';
        'Invoke' = 'Uninstall';
        'PassArgs' = $true
    };
    'start' = @{
        'ShortHelp' = 'Start the service';
        'LongHelp' = 'Starts the installed windows service';
        'Usage' = '';
        'Invoke' = 'Start-SVC'
    };
    'stop' = @{
        'ShortHelp' = 'Stop the service';
        'LongHelp' = 'Stops the installed windows service';
        'Usage' = '';
        'Invoke' = 'Stop-SVC'
    };
    'restart' = @{
        'ShortHelp' = 'Restart the service';
        'LongHelp' = 'Restarts the installed windows service';
        'Usage' = '';
        'Invoke' = @('Stop-SVC','Start-SVC')
    };
    'upgrade' = @{
        'ShortHelp' = 'Upgrade the running service';
        'LongHelp' = 'Upgrades the service to release <version>';
        'Usage' = '<version> [--no-permanent]';
        'Invoke' = 'Relup';
        'PassArgs' = $true
    };
    'downgrade' = @{
        'ShortHelp' = 'Downgrade the running service';
        'LongHelp' = 'Downgrades the service to release <version>';
        'Usage' = '<version>';
        'Invoke' = 'Relup';
        'PassArgs' = $true
    };
    'console' = @{
        'ShortHelp' = 'Start the release with an interactive shell';
        'LongHelp' = 'Starts release VERSION with an interactive shell';
        'Usage' = '';
        'Invoke' = 'Console'
    };
    'ping' = @{
        'ShortHelp' = 'Print pong if the node is alive';
        'LongHelp' = 'Checks if the service (or console) is running';
        'Usage' = '';
        'Invoke' = 'Ping'
    };
    'list' = @{
        'ShortHelp' = 'List installed Erlang services';
        'LongHelp' = 'Lists all Erlang services installed on this machine';
        'Usage' = '';
        'Invoke' = 'List'
    };
    'attach' = @{
        'ShortHelp' = 'Connect remote shell to running node';
        'LongHelp' = 'Connects to running service or console shell';
        'Usage' = '';
        'Invoke' = 'Attach'
    };
    'remote_console' = @{
        'ShortHelp' = 'Connect remote shell to running node';
        'LongHelp' = 'Connects to running service or console shell';
        'Usage' = '';
        'Invoke' = 'Attach'
    }
}

# Output usage
function Usage() {
    param(
        [string]$Command
    )
    switch ($Command) {
        {$commands.ContainsKey($Command)} {
            $cmd = $commands.item($_)
            "Usage: $($MyInvocation.MyCommand.Name) $Command $($cmd.Usage)"
            "$($cmd.LongHelp)"
        }
        {$extensions -contains $_} { RunExtension $_ help }
        Default {
            "Usage: $($MyInvocation.MyCommand.Name) <command> <args>"
            "Commands:"
            $commands.keys | ForEach-Object { @{"$_" = $commands.item($_).ShortHelp } } | Format-Table -HideTableHeaders
        }
    }
}

# Install the service
function Install() {
    param(
        [string]$Version
    )
    if (![string]::IsNullOrWhiteSpace($Version)) {
        # relup and reldown
        Relup $Version
        return
    }
    # Install the service
    $args = "$erl_opts -setcookie $cookie ++ -rootdir $erts_root -reldir $rootdir\releases"
    $start_erl = "$erts_dir\bin\start_erl.exe"
    $description = "Erlang node ${node_name}${hostname} in $rootdir"
    $params = @('add', $service_name, $node_type, "${node_name}${hostname}", `
        '-c', $description, `
        '-w', $rootdir, `
        '-m', $start_erl, `
        #'-d', 'reuse', ` # Add this to debug startup
        '-e', "ERL_LIBS=$rootdir\lib", `
        '-stopaction', 'init:stop().', `
        '-args', $args)
    & $erlsrv $params
}

# Uninstall the Windows service
function Uninstall() {
    param(
        [string]$Version
    )
    if (![string]::IsNullOrWhiteSpace($Version)) {
        # relup and reldown
        Relup $Version
        return
    }
    # Uninstall the Windows service
    & $erlsrv remove $service_name
    & $epmd -kill
}

# Start the Windows service
function Start-SVC() {
    & $erlsrv start $service_name
}

# Stop the Windows service
function Stop-SVC() {
    & $erlsrv stop $service_name
}

# Relup and reldown
function Relup() {
    param(
        [string]$Version
    )
    $params = @("$rootdir/bin/install_upgrade.escript", 'install', `
        "{'$rel_name', `"$node_type`", '${node_name}${hostname}', '$cookie'}", `
        $Version)
    & $escript $params @args
}

# Start a console
function Console() {
    # Set the ERL_LIBS environment variable
    $env:ERL_LIBS = "$rootdir\lib"

    # Start the release in an `erl` shell
    $params = @($erl_opts, '-boot', $boot_script)
    if (![string]::IsNullOrEmpty($sys_config)) { $params += '-config', $sys_config }
    if (![string]::IsNullOrEmpty($vm_args))    { $params += '-args_file', $vm_args }
    & $werl $params
}

# Ping the running node
function Ping() {
    $params = @($nodetool, 'ping', $node_type, "${node_name}${hostname}", '-setcookie', $cookie)
    & $escript $params
}

# List installed Erlang services
function List() {
    & $erlsrv 'list' $service_name
}

# Attach to a running node
function Attach() {
    $params = @('-boot', "$rel_dir\start_clean", `
        '-remsh', "${node_name}${hostname}", `
        $node_type, "console_${node_name}_$(Get-Random -maximum 99999)", `
        '-setcookie', $cookie)
    & $werl $params
}

# Run a command
function RunCommand()
{
    param(
        [string]$Name
    )
    $cmd = $commands.item($Name)
    if ($cmd.PassArgs) { $pass_args = $args }
    $cmd.Invoke | ForEach-Object {
        & $_ @pass_args
    }
}

# Finally, here is where we run the command
switch ($Command)
{
    "" { Usage }
    {$commands.ContainsKey($_)} {
        RunCommand $_ @args
    }
    {$extensions -contains $_} {
        RunExtension $_ @args
    }
    Default {
        Write-Warning "Unknown command: `"$_`""
        Usage
    }
}
